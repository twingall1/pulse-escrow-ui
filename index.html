<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Pulsecrow ‚Äì Trustless Escrow (Verification-first)</title>
<script src="https://cdn.jsdelivr.net/npm/ethers@6.8.1/dist/ethers.umd.min.js"></script>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",sans-serif;max-width:720px;margin:24px auto;padding:16px;color:#111;background:#f8fafc}
  h1{margin:0 0 12px} .card{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:16px;margin:14px 0}
  input,button{width:100%;padding:10px;margin:6px 0;border-radius:8px;border:1px solid #d1d5db;font-size:15px}
  button{background:#2563eb;color:#fff;border:none;font-weight:600;cursor:pointer}
  button:disabled{background:#9ca3af;cursor:not-allowed}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .muted{color:#555;font-size:13px} .ok{color:#065f46} .warn{color:#9a3412} .bad{color:#991b1b}
  code{background:#f1f5f9;padding:2px 4px;border-radius:4px}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace}
</style>
</head>
<body>
<h1>Pulsecrow</h1>
<p class="muted">Trustless two-deposit escrow on PulseChain ‚Ä¢ Works with MetaMask or OKX</p>

<div class="card">
  <button id="connect">üîó Connect Wallet</button>
  <div id="who" class="muted"></div>
</div>

<div class="card">
  <h3>Create Escrow</h3>
  <div class="row">
    <input id="partyB" placeholder="Party B address">
    <input id="deadlineMins" placeholder="Deadline minutes (e.g. 30)">
  </div>
  <div class="row">
    <input id="tokenA" placeholder="Token A (address or 0x0 for PLS)">
    <input id="decA" placeholder="A decimals (e.g. 18)">
  </div>
  <input id="amtA" placeholder="Amount A (human units, e.g. 1.5)">
  <div class="row">
    <input id="tokenB" placeholder="Token B (address or 0x0 for PLS)">
    <input id="decB" placeholder="B decimals (e.g. 18)">
  </div>
  <input id="amtB" placeholder="Amount B (human units)">
  <button id="create" disabled>Create Escrow</button>
  <div id="created" class="muted"></div>
</div>

<div class="card">
  <h3>Verify / Join Escrow</h3>
  <input id="escrow" placeholder="Escrow contract address (from link)">
  <button id="load">üîç Verify On-Chain</button>
  <div id="verifystatus" class="muted"></div>

  <div class="row">
    <div>
      <h4>On-Chain (what contract says)</h4>
      <div id="onchain" class="mono"></div>
    </div>
    <div>
      <h4>What you expect (what you agreed)</h4>
      <div class="row">
        <input id="expTokenA" placeholder="Token A (address or 0x0)">
        <input id="expDecA" placeholder="A decimals">
      </div>
      <input id="expAmtA" placeholder="Amount A (human)">
      <div class="row">
        <input id="expTokenB" placeholder="Token B (address or 0x0)">
        <input id="expDecB" placeholder="B decimals">
      </div>
      <input id="expAmtB" placeholder="Amount B (human)">
      <button id="compare">‚úÖ Compare</button>
      <div id="compareresult" class="muted"></div>
    </div>
  </div>

  <hr>
  <div class="row">
    <button id="approve" disabled>Approve My Token</button>
    <button id="deposit" disabled>Deposit My Token</button>
  </div>
  <div class="row">
    <button id="settle" disabled>Settle</button>
    <button id="refund" disabled>Refund</button>
  </div>
</div>

<div class="card">
  <h3>Status</h3>
  <div id="status" class="mono"></div>
</div>

<script>
/*** CONFIG ***/
const READONLY_RPC = "https://rpc.pulsechain.com";
const FACTORY = "0xb42529b2A66FD430a872788c83b10B285886b963";

/*** ABIs kept minimal and tolerant ***/
const factoryABI = [
  "function createEscrow(address,address,address,address,uint256,uint256,uint256) external returns(address)",
  "event EscrowCreated(address indexed creator,address escrowAddress)"
];

const escrowABI = [
  "function partyA() view returns(address)",
  "function partyB() view returns(address)",
  "function tokenA() view returns(address)",
  "function tokenB() view returns(address)",
  "function amountA() view returns(uint256)",
  "function amountB() view returns(uint256)",
  "function depositedA() view returns(bool)",
  "function depositedB() view returns(bool)",
  "function depositA() external payable",
  "function depositB() external payable",
  "function settle() external",
  "function refundA() external",
  "function refundB() external",
  // Some versions may not have deadline(); we'll try/catch.
  "function deadline() view returns(uint256)"
];

let providerRO = new ethers.JsonRpcProvider(READONLY_RPC);
let provider, signer, my;

/*** Helpers ***/
const $ = (id) => document.getElementById(id);
const toUnits = (bn, dec) => Number(ethers.formatUnits(bn, dec));
const toWei = (n, dec) => ethers.parseUnits(String(n), dec);
const ZERO = "0x0000000000000000000000000000000000000000";
const fmtAddr = (a) => a ? a : "(n/a)";

async function isContract(addr) {
  try { return (await (provider || providerRO).getCode(addr)) !== "0x"; }
  catch { return false; }
}

function setStatus(msg, cls="") {
  const el = $("status");
  el.textContent = msg;
  el.className = cls;
}

function prettyDeadline(ts) {
  if (!ts || ts === 0n) return "(no deadline fn)";
  const n = Number(ts) * 1000;
  return new Date(n).toUTCString() + ` (unix ${ts})`;
}

/*** Connect ***/
$("connect").onclick = async () => {
  if (!window.ethereum) return alert("Install MetaMask or OKX");
  provider = new ethers.BrowserProvider(window.ethereum);
  await provider.send("eth_requestAccounts", []);
  signer = await provider.getSigner();
  my = await signer.getAddress();
  $("who").textContent = `Connected: ${my}`;
  $("create").disabled = false;
};

/*** CREATE ***/
$("create").onclick = async () => {
  try {
    if (!signer) return alert("Connect wallet first");
    const partyB = $("partyB").value.trim();
    const tokenA = $("tokenA").value.trim() || ZERO;
    const tokenB = $("tokenB").value.trim() || ZERO;
    const decA = parseInt($("decA").value) || 18;
    const decB = parseInt($("decB").value) || 18;
    const amtA = toWei($("amtA").value, decA);
    const amtB = toWei($("amtB").value, decB);
    const mins = parseInt($("deadlineMins").value) || 30;
    const deadline = Math.floor(Date.now()/1000) + mins*60;

    const f = new ethers.Contract(FACTORY, factoryABI, signer);
    const tx = await f.createEscrow(my, partyB, tokenA, tokenB, amtA, amtB, deadline);
    const rc = await tx.wait();
    const ev = rc.logs?.find(l => l.fragment?.name === "EscrowCreated");
    const esc = ev ? ev.args.escrowAddress : "(unknown)";
    const link = `${location.origin}${location.pathname}?escrow=${esc}`;
    $("created").innerHTML = `‚úÖ Created: <code>${esc}</code><br>Share: <a href="${link}" target="_blank">${link}</a>`;
    $("escrow").value = esc;
  } catch (e) {
    alert("Create error: " + (e?.reason || e?.message || e));
  }
};

/*** VERIFY (loads on-chain, tolerant to missing functions) ***/
$("load").onclick = async () => {
  try {
    const esc = $("escrow").value.trim();
    if (!ethers.isAddress(esc)) return alert("Invalid address");
    if (!(await isContract(esc))) {
      $("verifystatus").innerHTML = `<span class="bad">‚ùå No contract code at this address.</span>`;
      $("onchain").textContent = "";
      return;
    }
    const e = new ethers.Contract(esc, escrowABI, provider || providerRO);

    // Safe try for each read (if a function doesn't exist, it will throw; we catch and show n/a)
    async function read(fn) {
      try { return await e[fn](); } catch { return null; }
    }

    const [partyA, partyB, tokenA, tokenB, amountA, amountB, depA, depB, deadline] =
      await Promise.all([
        read("partyA"), read("partyB"), read("tokenA"), read("tokenB"),
        read("amountA"), read("amountB"), read("depositedA"), read("depositedB"), read("deadline")
      ]);

    if (tokenA === null || tokenB === null || amountA === null || amountB === null) {
      $("verifystatus").innerHTML = `<span class="bad">‚ùå This address is not a compatible Pulsecrow escrow (core getters missing).</span>`;
      $("onchain").textContent = "";
      return;
    }

    // Resolve decimals if you want to display human units nicely; default to 18 if fail
    async function decimalsOf(addr) {
      if (!addr || addr.toLowerCase() === ZERO) return 18;
      try {
        const t = new ethers.Contract(addr, ["function decimals() view returns (uint8)"], provider || providerRO);
        return await t.decimals();
      } catch { return 18; }
    }

    const decA = await decimalsOf(tokenA);
    const decB = await decimalsOf(tokenB);

    const humanA = Number(ethers.formatUnits(amountA, decA));
    const humanB = Number(ethers.formatUnits(amountB, decB));

    $("verifystatus").innerHTML = `<span class="ok">‚úÖ Contract verified at this address.</span>`;
    $("onchain").innerHTML =
`partyA: ${partyA}
partyB: ${partyB}
tokenA: ${fmtAddr(tokenA)}   amountA: ${humanA} (raw ${amountA})
tokenB: ${fmtAddr(tokenB)}   amountB: ${humanB} (raw ${amountB})
depositedA: ${depA}
depositedB: ${depB}
deadline: ${deadline!==null?prettyDeadline(deadline):"(no deadline fn)"}`
    ;
  } catch (e) {
    $("verifystatus").innerHTML = `<span class="bad">‚ùå Verify error: ${e?.message || e}</span>`;
  }
};

/*** COMPARE expected vs on-chain and unlock buttons ***/
$("compare").onclick = async () => {
  try {
    const esc = $("escrow").value.trim();
    if (!ethers.isAddress(esc) || !(await isContract(esc)))
      return $("compareresult").innerHTML = `<span class="bad">‚ùå Load a valid escrow first.</span>`;

    const e = new ethers.Contract(esc, escrowABI, provider || providerRO);
    const [onA, onB, onAmtA, onAmtB] = await Promise.all([
      e.tokenA(), e.tokenB(), e.amountA(), e.amountB()
    ]);

    const expA = $("expTokenA").value.trim() || ZERO;
    const expB = $("expTokenB").value.trim() || ZERO;
    const dA = parseInt($("expDecA").value) || 18;
    const dB = parseInt($("expDecB").value) || 18;

    const vA = Number($("expAmtA").value);
    const vB = Number($("expAmtB").value);
    if (!Number.isFinite(vA) || !Number.isFinite(vB))
      return $("compareresult").innerHTML = `<span class="warn">‚ö†Ô∏è Enter numeric amounts to compare.</span>`;

    const rawA = toWei(vA, dA);
    const rawB = toWei(vB, dB);

    const match =
      (expA.toLowerCase() === onA.toLowerCase()) &&
      (expB.toLowerCase() === onB.toLowerCase()) &&
      (rawA === onAmtA) &&
      (rawB === onAmtB);

    if (match) {
      $("compareresult").innerHTML = `<span class="ok">‚úÖ Matches exactly. You can proceed.</span>`;
      // Enable action buttons
      ["approve","deposit","settle","refund"].forEach(id => $(id).disabled = false);
    } else {
      $("compareresult").innerHTML = `<span class="bad">‚ùå Does not match on-chain. Do not proceed.</span>`;
      ["approve","deposit","settle","refund"].forEach(id => $(id).disabled = true);
    }
  } catch (e) {
    $("compareresult").innerHTML = `<span class="bad">‚ùå Compare error: ${e?.message || e}</span>`;
  }
};

/*** ACTIONS with safety checks ***/
$("approve").onclick = async () => {
  try {
    if (!signer) return alert("Connect wallet first");
    const esc = $("escrow").value.trim();
    const e = new ethers.Contract(esc, escrowABI, signer);
    const [a,b,tA,tB,amtA,amtB] = await Promise.all([e.partyA(),e.partyB(),e.tokenA(),e.tokenB(),e.amountA(),e.amountB()]);
    const me = (await signer.getAddress()).toLowerCase();
    const isA = me === a.toLowerCase(), isB = me === b.toLowerCase();
    if (!isA && !isB) return alert("This wallet is not party A or B");

    const token = isA ? tA : tB;
    if (token === ZERO) return alert("Native PLS requires no approval.");

    const need = isA ? amtA : amtB;
    const erc = new ethers.Contract(token, [
      "function allowance(address,address) view returns(uint256)",
      "function approve(address,uint256) returns(bool)"
    ], signer);

    const allowance = await erc.allowance(me, esc);
    if (allowance >= need) { setStatus("‚úÖ Already approved."); return; }

    setStatus("‚è≥ Waiting for approval...");
    const tx = await erc.approve(esc, need); await tx.wait();
    setStatus("‚úÖ Approved.");
  } catch (e) { setStatus("Approval error: "+(e?.message||e), "bad"); }
};

$("deposit").onclick = async () => {
  try {
    if (!signer) return alert("Connect wallet first");
    const esc = $("escrow").value.trim();
    const e = new ethers.Contract(esc, escrowABI, signer);
    const [a,b,tA,tB,amtA,amtB] = await Promise.all([e.partyA(),e.partyB(),e.tokenA(),e.tokenB(),e.amountA(),e.amountB()]);
    const me = (await signer.getAddress()).toLowerCase();
    const isA = me === a.toLowerCase(), isB = me === b.toLowerCase();
    if (!isA && !isB) return alert("This wallet is not party A or B");

    // deadline (tolerant)
    try {
      const dl = await e.deadline();
      if (dl && BigInt(Math.floor(Date.now()/1000)) > dl) return alert("‚è∞ Deadline expired.");
    } catch {}

    const token = isA ? tA : tB;
    const need = isA ? amtA : amtB;

    if (token !== ZERO) {
      const erc = new ethers.Contract(token, ["function allowance(address,address) view returns(uint256)"], signer);
      const allowance = await erc.allowance(me, esc);
      if (allowance < need) return alert("‚ö†Ô∏è Not approved / insufficient allowance.");
    }

    setStatus("‚è≥ Waiting for deposit...");
    const tx = (token === ZERO)
      ? await (isA ? e.depositA({ value: need }) : e.depositB({ value: need }))
      : await (isA ? e.depositA() : e.depositB());
    await tx.wait();
    setStatus("‚úÖ Deposit complete.");
  } catch (e) { setStatus("Deposit error: "+(e?.reason||e?.message||e), "bad"); }
};

$("settle").onclick = async () => {
  try {
    if (!signer) return alert("Connect wallet first");
    const e = new ethers.Contract($("escrow").value.trim(), escrowABI, signer);
    setStatus("‚è≥ Waiting to settle...");
    const tx = await e.settle(); await tx.wait();
    setStatus("‚úÖ Settled. Tokens swapped.");
  } catch (e) { setStatus("Settle error: "+(e?.message||e), "bad"); }
};

$("refund").onclick = async () => {
  try {
    if (!signer) return alert("Connect wallet first");
    const e = new ethers.Contract($("escrow").value.trim(), escrowABI, signer);
    const a = await e.partyA();
    const me = (await signer.getAddress()).toLowerCase();
    const isA = me === a.toLowerCase();
    setStatus("‚è≥ Waiting for refund...");
    const tx = await (isA ? e.refundA() : e.refundB());
    await tx.wait();
    setStatus("‚úÖ Refunded.");
  } catch (e) { setStatus("Refund error: "+(e?.message||e), "bad"); }
};

/*** Autofill from ?escrow= ***/
const p = new URLSearchParams(location.search);
const escParam = p.get("escrow");
if (escParam) $("escrow").value = escParam;
</script>
</body>
</html>
